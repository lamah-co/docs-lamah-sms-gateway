---
title: 'Development Guide'
description: 'Best practices for developing with the Lamah SMS API'
---

## Development Environment Setup

Setting up a proper development environment is crucial for building robust SMS applications with the Lamah API.

### API Token Management

<Warning>
  Never expose your API tokens in client-side code or public repositories. Always use environment variables or secure configuration management.
</Warning>

<CodeGroup>

```bash Environment Variables
# .env file
LAMAH_API_TOKEN=your_api_token_here
LAMAH_BASE_URL=https://sms.lamah.com
```

```javascript Node.js Setup
// config.js
const config = {
  lamah: {
    apiToken: process.env.LAMAH_API_TOKEN,
    baseUrl: process.env.LAMAH_BASE_URL || 'https://sms.lamah.com'
  }
};

module.exports = config;
```

```python Python Setup
# config.py
import os
from dotenv import load_dotenv

load_dotenv()

LAMAH_API_TOKEN = os.getenv('LAMAH_API_TOKEN')
LAMAH_BASE_URL = os.getenv('LAMAH_BASE_URL', 'https://sms.lamah.com')
```

</CodeGroup>

## Testing Strategies

### Unit Testing

Test your SMS integration logic without actually sending messages:

<CodeGroup>

```javascript Jest Testing
// sms.test.js
const SMSService = require('./sms-service');

// Mock the fetch function
global.fetch = jest.fn();

describe('SMS Service', () => {
  beforeEach(() => {
    fetch.mockClear();
  });

  test('should send SMS successfully', async () => {
    const mockResponse = {
      message_id: 'msg_123',
      status: 'sent',
      cost: 0.05
    };

    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse
    });

    const smsService = new SMSService('test-token');
    const result = await smsService.sendMessage({
      message: 'رسالة تجريبية من خدمة لمحة',
      receiver: '00218912345678',
      sender: 'Lamah'
    });

    expect(result.success).toBe(true);
    expect(result.data.message_id).toBe('msg_123');
    expect(fetch).toHaveBeenCalledWith(
      'https://sms.lamah.com/api/sms/messages',
      expect.objectContaining({
        method: 'POST',
        headers: expect.objectContaining({
          'Authorization': 'Bearer test-token'
        })
      })
    );
  });
});
```

```python pytest Testing
# test_sms.py
import pytest
from unittest.mock import Mock, patch
from sms_service import SMSService

@pytest.fixture
def sms_service():
    return SMSService('test-token')

@patch('requests.post')
def test_send_sms_success(mock_post, sms_service):
    # Mock successful response
    mock_response = Mock()
    mock_response.ok = True
    mock_response.json.return_value = {
        'message_id': 'msg_123',
        'status': 'sent',
        'cost': 0.05
    }
    mock_post.return_value = mock_response

    result = sms_service.send_message(
        message='رسالة تجريبية من خدمة لمحة',
        receiver='00218912345678',
        sender='Lamah'
    )

    assert result['success'] is True
    assert result['data']['message_id'] == 'msg_123'
    mock_post.assert_called_once()
```

</CodeGroup>

### Integration Testing

Test with the actual API using test phone numbers:

<CodeGroup>

```javascript Integration Test
// integration.test.js
const SMSService = require('./sms-service');

describe('SMS Integration Tests', () => {
  const smsService = new SMSService(process.env.LAMAH_TEST_TOKEN);
  const testPhoneNumber = process.env.TEST_PHONE_NUMBER;

  test('should send real SMS to test number', async () => {
    if (!testPhoneNumber) {
      console.log('Skipping integration test - no test phone number');
      return;
    }

    const result = await smsService.sendMessage({
      message: 'رسالة اختبار تكامل من خدمة لمحة',
      receiver: testPhoneNumber,
      sender: 'Lamah',
      payment_type: 'wallet'
    });

    expect(result.success).toBe(true);
    expect(result.data.message_id).toBeDefined();

    // Wait and check message status
    await new Promise(resolve => setTimeout(resolve, 5000));

    const status = await smsService.getMessageStatus(result.data.message_id);
    expect(['sent', 'delivered']).toContain(status.status);
  }, 30000); // 30 second timeout
});
```

</CodeGroup>

## Error Handling Best Practices

### Comprehensive Error Handling

<CodeGroup>

```javascript Error Handling
class SMSService {
  async sendMessage(messageData) {
    try {
      const response = await fetch(`${this.baseUrl}/api/sms/messages`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(messageData)
      });

      if (!response.ok) {
        const error = await response.json();
        return this.handleAPIError(error, response.status);
      }

      const result = await response.json();
      return { success: true, data: result };

    } catch (error) {
      console.error('Network error:', error);
      return {
        success: false,
        error: 'NETWORK_ERROR',
        message: 'Failed to connect to SMS service',
        retryable: true
      };
    }
  }

  handleAPIError(error, statusCode) {
    const errorMap = {
      400: { retryable: false, category: 'CLIENT_ERROR' },
      401: { retryable: false, category: 'AUTH_ERROR' },
      402: { retryable: false, category: 'PAYMENT_ERROR' },
      429: { retryable: true, category: 'RATE_LIMIT' },
      500: { retryable: true, category: 'SERVER_ERROR' }
    };

    const errorInfo = errorMap[statusCode] || { retryable: false, category: 'UNKNOWN' };

    return {
      success: false,
      error: error.code || 'API_ERROR',
      message: error.error || 'Unknown API error',
      ...errorInfo,
      details: error.details
    };
  }
}
```

```python Error Handling
import requests
import time
from typing import Dict, Any

class SMSService:
    def __init__(self, api_token: str):
        self.api_token = api_token
        self.base_url = 'https://sms.lamah.com'

    def send_message(self, message_data: Dict[str, Any], max_retries: int = 3) -> Dict[str, Any]:
        for attempt in range(max_retries + 1):
            try:
                response = requests.post(
                    f'{self.base_url}/api/sms/messages',
                    headers={
                        'Authorization': f'Bearer {self.api_token}',
                        'Content-Type': 'application/json'
                    },
                    json=message_data,
                    timeout=30
                )

                if response.ok:
                    return {'success': True, 'data': response.json()}

                error_data = response.json()
                error_result = self._handle_api_error(error_data, response.status_code)

                # Retry for retryable errors
                if error_result.get('retryable') and attempt < max_retries:
                    wait_time = 2 ** attempt  # Exponential backoff
                    time.sleep(wait_time)
                    continue

                return error_result

            except requests.exceptions.Timeout:
                if attempt < max_retries:
                    time.sleep(2 ** attempt)
                    continue
                return {
                    'success': False,
                    'error': 'TIMEOUT',
                    'message': 'Request timed out',
                    'retryable': True
                }
            except requests.exceptions.ConnectionError:
                if attempt < max_retries:
                    time.sleep(2 ** attempt)
                    continue
                return {
                    'success': False,
                    'error': 'CONNECTION_ERROR',
                    'message': 'Failed to connect to SMS service',
                    'retryable': True
                }

        return {
            'success': False,
            'error': 'MAX_RETRIES_EXCEEDED',
            'message': 'Maximum retry attempts exceeded'
        }

    def _handle_api_error(self, error_data: Dict, status_code: int) -> Dict[str, Any]:
        error_map = {
            400: {'retryable': False, 'category': 'CLIENT_ERROR'},
            401: {'retryable': False, 'category': 'AUTH_ERROR'},
            402: {'retryable': False, 'category': 'PAYMENT_ERROR'},
            429: {'retryable': True, 'category': 'RATE_LIMIT'},
            500: {'retryable': True, 'category': 'SERVER_ERROR'}
        }

        error_info = error_map.get(status_code, {'retryable': False, 'category': 'UNKNOWN'})

        return {
            'success': False,
            'error': error_data.get('code', 'API_ERROR'),
            'message': error_data.get('error', 'Unknown API error'),
            **error_info,
            'details': error_data.get('details')
        }
```

</CodeGroup>

## Rate Limiting and Retry Logic

### Implementing Backoff Strategies

<CodeGroup>

```javascript Rate Limiting
class RateLimitedSMSService {
  constructor(apiToken, maxRequestsPerMinute = 100) {
    this.apiToken = apiToken;
    this.maxRequestsPerMinute = maxRequestsPerMinute;
    this.requestQueue = [];
    this.processing = false;
  }

  async sendMessage(messageData) {
    return new Promise((resolve, reject) => {
      this.requestQueue.push({ messageData, resolve, reject });
      this.processQueue();
    });
  }

  async processQueue() {
    if (this.processing || this.requestQueue.length === 0) {
      return;
    }

    this.processing = true;
    const intervalMs = (60 * 1000) / this.maxRequestsPerMinute;

    while (this.requestQueue.length > 0) {
      const { messageData, resolve, reject } = this.requestQueue.shift();

      try {
        const result = await this.makeRequest(messageData);
        resolve(result);
      } catch (error) {
        reject(error);
      }

      // Wait before next request
      if (this.requestQueue.length > 0) {
        await new Promise(resolve => setTimeout(resolve, intervalMs));
      }
    }

    this.processing = false;
  }

  async makeRequest(messageData) {
    // Implement actual API request with retry logic
    return this.sendWithRetry(messageData);
  }
}
```

</CodeGroup>


## Performance Optimization

### Connection Pooling and Caching

<CodeGroup>

```javascript Performance Tips
// Use connection pooling for high-volume applications
const https = require('https');

const agent = new https.Agent({
  keepAlive: true,
  maxSockets: 50,
  maxFreeSockets: 10,
  timeout: 60000,
  freeSocketTimeout: 30000
});

// Cache frequently accessed data
class SMSServiceWithCache {
  constructor(apiToken) {
    this.apiToken = apiToken;
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
  }

  async getProjectDetails() {
    const cacheKey = 'project_details';
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data;
    }

    const details = await this.fetchProjectDetails();
    this.cache.set(cacheKey, {
      data: details,
      timestamp: Date.now()
    });

    return details;
  }
}
```

</CodeGroup>

## Monitoring and Logging

### Structured Logging

<CodeGroup>

```javascript Logging
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'sms-error.log', level: 'error' }),
    new winston.transports.File({ filename: 'sms-combined.log' })
  ]
});

class SMSService {
  async sendMessage(messageData) {
    const startTime = Date.now();

    logger.info('SMS send initiated', {
      receiver: messageData.receiver,
      sender: messageData.sender,
      messageLength: messageData.message.length
    });

    try {
      const result = await this.makeAPICall(messageData);

      logger.info('SMS sent successfully', {
        messageId: result.message_id,
        cost: result.cost,
        duration: Date.now() - startTime
      });

      return result;
    } catch (error) {
      logger.error('SMS send failed', {
        error: error.message,
        receiver: messageData.receiver,
        duration: Date.now() - startTime
      });
      throw error;
    }
  }
}
```

</CodeGroup>

## Security Best Practices

<CardGroup cols={2}>
  <Card title="Token Security" icon="key">
    Store API tokens securely and rotate them regularly
  </Card>
  <Card title="Input Validation" icon="shield-check">
    Validate all phone numbers and message content
  </Card>
  <Card title="Rate Limiting" icon="gauge">
    Implement client-side rate limiting to prevent abuse
  </Card>
</CardGroup>
