---
title: 'Error Handling'
description: 'Comprehensive guide to handling errors in the Lamah SMS API'
---

## Overview

Proper error handling is crucial for building robust SMS applications. This guide covers all error types, status codes, and best practices for handling failures gracefully.

## HTTP Status Codes

The Lamah SMS API uses standard HTTP status codes to indicate the success or failure of requests:

| Status Code | Description | Action Required |
|-------------|-------------|-----------------|
| `200` | Success | Continue normal operation |
| `400` | Bad Request | Fix request parameters |
| `401` | Unauthorized | Check API token |
| `402` | Payment Required | Add funds or upgrade plan |
| `403` | Forbidden | Check permissions |
| `404` | Not Found | Verify resource exists |
| `429` | Too Many Requests | Implement rate limiting |
| `500` | Internal Server Error | Retry request |

## Error Response Format

All error responses follow a consistent JSON format:

```json
{
  "error": "Human-readable error message",
  "code": "MACHINE_READABLE_ERROR_CODE",
  "details": {
    "field": "specific_field_name",
    "value": "invalid_value",
    "additional_info": "context"
  }
}
```

## Common Error Codes

### Authentication Errors

<AccordionGroup>
  <Accordion title="UNAUTHORIZED - Invalid API Token">
    ```json
    {
      "error": "Invalid API token",
      "code": "UNAUTHORIZED"
    }
    ```
    
    **Causes:**
    - Missing Authorization header
    - Invalid token format
    - Expired or revoked token
    
    **Solutions:**
    - Verify token is included in Authorization header
    - Check token format: `Bearer YOUR_TOKEN`
    - Generate a new token from dashboard
  </Accordion>
  
  <Accordion title="ACCESS_DENIED - Insufficient Permissions">
    ```json
    {
      "error": "Insufficient permissions to access this resource",
      "code": "ACCESS_DENIED"
    }
    ```
    
    **Causes:**
    - Token doesn't have required permissions
    - Accessing resources from different project
    
    **Solutions:**
    - Use correct project token
    - Contact support for permission issues
  </Accordion>
</AccordionGroup>

### Validation Errors

<AccordionGroup>
  <Accordion title="INVALID_PHONE - Invalid Phone Number">
    ```json
    {
      "error": "Invalid phone number format",
      "code": "INVALID_PHONE",
      "details": {
        "field": "receiver",
        "value": "123456789"
      }
    }
    ```
    
    **Solutions:**
    - Use international format with country code
    - Example: `00218912345678`
    - Validate numbers before sending
  </Accordion>
  
  <Accordion title="MESSAGE_TOO_LONG - Message Exceeds Limit">
    ```json
    {
      "error": "Message exceeds maximum length",
      "code": "MESSAGE_TOO_LONG",
      "details": {
        "max_length": 1530,
        "actual_length": 1600
      }
    }
    ```
    
    **Solutions:**
    - Trim message to fit limits
    - Split into multiple messages
    - Use templates for consistent formatting
  </Accordion>
</AccordionGroup>

### Payment Errors

<AccordionGroup>
  <Accordion title="INSUFFICIENT_BALANCE - Low Account Balance">
    ```json
    {
      "error": "Insufficient balance to send SMS",
      "code": "INSUFFICIENT_BALANCE",
      "details": {
        "required": 0.05,
        "available": 0.02
      }
    }
    ```
    
    **Solutions:**
    - Add funds to your account
    - Enable auto-recharge
    - Switch to subscription plan
  </Accordion>
  
  <Accordion title="PAYMENT_METHOD_FAILED - Payment Issue">
    ```json
    {
      "error": "Payment method declined",
      "code": "PAYMENT_METHOD_FAILED"
    }
    ```
    
    **Solutions:**
    - Update payment method
    - Contact your bank
    - Try alternative payment method
  </Accordion>
</AccordionGroup>

### Rate Limiting Errors

<AccordionGroup>
  <Accordion title="RATE_LIMIT_EXCEEDED - Too Many Requests">
    ```json
    {
      "error": "Rate limit exceeded",
      "code": "RATE_LIMIT_EXCEEDED",
      "details": {
        "limit": 100,
        "window": "1 minute",
        "retry_after": 60
      }
    }
    ```
    
    **Solutions:**
    - Implement exponential backoff
    - Reduce request frequency
    - Use bulk endpoints for multiple messages
  </Accordion>
</AccordionGroup>

## Error Handling Strategies

### Basic Error Handling

<CodeGroup>

```javascript Basic Error Handling
const sendSMS = async (messageData) => {
  try {
    const response = await fetch('https://sms.lamah.com/api/sms/messages', {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer YOUR_API_TOKEN',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(messageData)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new APIError(error, response.status);
    }

    return await response.json();
  } catch (error) {
    console.error('SMS sending failed:', error);
    throw error;
  }
};

class APIError extends Error {
  constructor(errorData, statusCode) {
    super(errorData.error);
    this.code = errorData.code;
    this.statusCode = statusCode;
    this.details = errorData.details;
  }
}
```

```python Basic Error Handling
import requests

class LamahAPIError(Exception):
    def __init__(self, error_data, status_code):
        super().__init__(error_data.get('error'))
        self.code = error_data.get('code')
        self.status_code = status_code
        self.details = error_data.get('details')

def send_sms(message_data):
    try:
        response = requests.post(
            'https://sms.lamah.com/api/sms/messages',
            headers={
                'Authorization': 'Bearer YOUR_API_TOKEN',
                'Content-Type': 'application/json'
            },
            json=message_data
        )
        
        if not response.ok:
            error_data = response.json()
            raise LamahAPIError(error_data, response.status_code)
        
        return response.json()
        
    except requests.exceptions.RequestException as e:
        print(f'Network error: {e}')
        raise
```

</CodeGroup>

### Advanced Error Handling with Retry Logic

<CodeGroup>

```javascript Advanced Error Handling
class SMSService {
  constructor(apiToken) {
    this.apiToken = apiToken;
    this.baseUrl = 'https://sms.lamah.com';
  }

  async sendSMSWithRetry(messageData, maxRetries = 3) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.sendSMS(messageData);
        return { success: true, data: result };
      } catch (error) {
        const shouldRetry = this.shouldRetry(error, attempt, maxRetries);
        
        if (!shouldRetry) {
          return { success: false, error: this.formatError(error) };
        }

        const delay = this.calculateDelay(attempt);
        await this.sleep(delay);
      }
    }

    return { 
      success: false, 
      error: { code: 'MAX_RETRIES_EXCEEDED', message: 'Maximum retry attempts exceeded' }
    };
  }

  shouldRetry(error, attempt, maxRetries) {
    if (attempt >= maxRetries) return false;

    // Retry on network errors
    if (error.name === 'TypeError' || error.name === 'NetworkError') {
      return true;
    }

    // Retry on specific status codes
    const retryableStatusCodes = [429, 500, 502, 503, 504];
    return retryableStatusCodes.includes(error.statusCode);
  }

  calculateDelay(attempt) {
    // Exponential backoff with jitter
    const baseDelay = 1000; // 1 second
    const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
    const jitter = Math.random() * 1000; // Add up to 1 second of jitter
    return exponentialDelay + jitter;
  }

  formatError(error) {
    return {
      code: error.code || 'UNKNOWN_ERROR',
      message: error.message || 'An unknown error occurred',
      statusCode: error.statusCode,
      details: error.details,
      retryable: this.shouldRetry(error, 1, 2)
    };
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async sendSMS(messageData) {
    const response = await fetch(`${this.baseUrl}/api/sms/messages`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(messageData)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new APIError(error, response.status);
    }

    return response.json();
  }
}

// Usage
const smsService = new SMSService('YOUR_API_TOKEN');

const result = await smsService.sendSMSWithRetry({
  message: 'رسالة تجريبية من خدمة لمحة',
  receiver: '00218912345678',
  sender: 'Lamah',
  payment_type: 'wallet'
});

if (result.success) {
  console.log('SMS sent:', result.data.message_id);
} else {
  console.error('SMS failed:', result.error);
}
```

```python Advanced Error Handling
import requests
import time
import random
from typing import Dict, Any, Optional

class SMSService:
    def __init__(self, api_token: str):
        self.api_token = api_token
        self.base_url = 'https://sms.lamah.com'

    def send_sms_with_retry(self, message_data: Dict[str, Any], max_retries: int = 3) -> Dict[str, Any]:
        for attempt in range(1, max_retries + 1):
            try:
                result = self._send_sms(message_data)
                return {'success': True, 'data': result}
            except Exception as error:
                if not self._should_retry(error, attempt, max_retries):
                    return {'success': False, 'error': self._format_error(error)}
                
                delay = self._calculate_delay(attempt)
                time.sleep(delay)
        
        return {
            'success': False,
            'error': {
                'code': 'MAX_RETRIES_EXCEEDED',
                'message': 'Maximum retry attempts exceeded'
            }
        }

    def _should_retry(self, error: Exception, attempt: int, max_retries: int) -> bool:
        if attempt >= max_retries:
            return False
        
        # Retry on network errors
        if isinstance(error, (requests.exceptions.ConnectionError, 
                            requests.exceptions.Timeout)):
            return True
        
        # Retry on specific status codes
        if hasattr(error, 'status_code'):
            retryable_codes = [429, 500, 502, 503, 504]
            return error.status_code in retryable_codes
        
        return False

    def _calculate_delay(self, attempt: int) -> float:
        # Exponential backoff with jitter
        base_delay = 1.0  # 1 second
        exponential_delay = base_delay * (2 ** (attempt - 1))
        jitter = random.uniform(0, 1)  # Add up to 1 second of jitter
        return exponential_delay + jitter

    def _format_error(self, error: Exception) -> Dict[str, Any]:
        if hasattr(error, 'code'):
            return {
                'code': error.code,
                'message': str(error),
                'status_code': getattr(error, 'status_code', None),
                'details': getattr(error, 'details', None)
            }
        
        return {
            'code': 'UNKNOWN_ERROR',
            'message': str(error),
            'status_code': None,
            'details': None
        }

    def _send_sms(self, message_data: Dict[str, Any]) -> Dict[str, Any]:
        response = requests.post(
            f'{self.base_url}/api/sms/messages',
            headers={
                'Authorization': f'Bearer {self.api_token}',
                'Content-Type': 'application/json'
            },
            json=message_data,
            timeout=30
        )
        
        if not response.ok:
            error_data = response.json()
            raise LamahAPIError(error_data, response.status_code)
        
        return response.json()

# Usage
sms_service = SMSService('YOUR_API_TOKEN')

result = sms_service.send_sms_with_retry({
    'message': 'رسالة تجريبية من خدمة لمحة',
    'receiver': '00218912345678',
    'sender': 'Lamah',
    'payment_type': 'wallet'
})

if result['success']:
    print(f"SMS sent: {result['data']['message_id']}")
else:
    print(f"SMS failed: {result['error']}")
```

</CodeGroup>

## Error Monitoring and Alerting

### Logging Errors

<CodeGroup>

```javascript Error Logging
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

const sendSMSWithLogging = async (messageData) => {
  try {
    const result = await sendSMS(messageData);
    
    logger.info('SMS sent successfully', {
      messageId: result.message_id,
      receiver: messageData.receiver,
      cost: result.cost
    });
    
    return result;
  } catch (error) {
    logger.error('SMS sending failed', {
      error: error.message,
      code: error.code,
      receiver: messageData.receiver,
      statusCode: error.statusCode
    });
    
    // Send alert for critical errors
    if (error.statusCode >= 500) {
      await sendAlert('Critical SMS API error', error);
    }
    
    throw error;
  }
};
```

```python Error Logging
import logging
import json

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('sms_api.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

def send_sms_with_logging(message_data):
    try:
        result = send_sms(message_data)
        
        logger.info('SMS sent successfully', extra={
            'message_id': result['message_id'],
            'receiver': message_data['receiver'],
            'cost': result['cost']
        })
        
        return result
    except LamahAPIError as error:
        logger.error('SMS sending failed', extra={
            'error': str(error),
            'code': error.code,
            'receiver': message_data['receiver'],
            'status_code': error.status_code
        })
        
        # Send alert for critical errors
        if error.status_code >= 500:
            send_alert('Critical SMS API error', error)
        
        raise
```

</CodeGroup>

## Best Practices

<CardGroup cols={2}>
  <Card title="Graceful Degradation" icon="shield">
    Handle errors gracefully without breaking user experience
  </Card>
  <Card title="Retry Logic" icon="refresh">
    Implement exponential backoff for transient errors
  </Card>
  <Card title="Error Monitoring" icon="chart-line">
    Monitor error rates and set up alerts
  </Card>
  <Card title="User Feedback" icon="message">
    Provide meaningful error messages to users
  </Card>
</CardGroup>

### Error Recovery Strategies

1. **Immediate Retry**: For network timeouts
2. **Exponential Backoff**: For rate limiting
3. **Circuit Breaker**: For persistent failures
4. **Fallback Options**: Alternative communication methods
5. **User Notification**: Inform users of delivery issues

### Testing Error Scenarios

<CodeGroup>

```javascript Error Testing
describe('SMS Error Handling', () => {
  test('should handle insufficient balance', async () => {
    // Mock API response
    fetch.mockResolvedValueOnce({
      ok: false,
      status: 402,
      json: async () => ({
        error: 'Insufficient balance',
        code: 'INSUFFICIENT_BALANCE',
        details: { required: 0.05, available: 0.02 }
      })
    });

    const result = await smsService.sendSMSWithRetry(messageData);
    
    expect(result.success).toBe(false);
    expect(result.error.code).toBe('INSUFFICIENT_BALANCE');
  });

  test('should retry on rate limit', async () => {
    // Mock rate limit then success
    fetch
      .mockResolvedValueOnce({
        ok: false,
        status: 429,
        json: async () => ({ error: 'Rate limit exceeded', code: 'RATE_LIMIT_EXCEEDED' })
      })
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({ message_id: 'msg_123', status: 'sent' })
      });

    const result = await smsService.sendSMSWithRetry(messageData);
    
    expect(result.success).toBe(true);
    expect(fetch).toHaveBeenCalledTimes(2);
  });
});
```

</CodeGroup>
